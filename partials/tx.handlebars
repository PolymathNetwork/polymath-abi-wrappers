public {{this.tsName}} = {
    async sendTransactionAsync(
    {{> typed_params inputs=inputs}}
    {{#this.payable}}
        txData: Partial<TxDataPayable> = {},
    {{/this.payable}}
    {{^this.payable}}
        txData: Partial<TxData> = {},
    {{/this.payable}}
        estimateGasFactor?: number,
    ): Promise<PolyResponse> {
        const self = this as any as {{contractName}}Contract;
        const inputAbi = self._lookupAbi('{{this.functionSignature}}').inputs;
        [{{> params inputs=inputs}}] = BaseContract._formatABIDataItemList(inputAbi, [{{> params inputs=inputs}}], BaseContract._bigNumberToString.bind(self));
        BaseContract.strictArgumentEncodingCheck(inputAbi, [{{> params inputs=inputs}}]);
        const encodedData = self._lookupEthersInterface('{{this.functionSignature}}').functions.{{this.name}}.encode([{{> params inputs=inputs}}]);
        const defaultFromAddress = (await self._web3Wrapper.getAvailableAddressesAsync())[0];
        const contractDefaults = _.defaults(
                self._web3Wrapper.getContractDefaults(),
                {
                    from: defaultFromAddress 
                }
            );
        const txDataWithDefaults = await BaseContract._applyDefaultsToTxDataAsync(
            {
                to: self.address,
                ...txData,
                data: encodedData,
            },
            contractDefaults,
            self.{{this.tsName}}.estimateGasAsync.bind<{{contractName}}Contract, any, Promise<number>>(
                self,
                {{> params inputs=inputs}}{{#if inputs.length}},{{/if}}
                estimateGasFactor,
            ),
        );
        const txHash = await self._web3Wrapper.sendTransactionAsync(txDataWithDefaults);
        const receipt = self._web3Wrapper.awaitTransactionSuccessAsync(txHash);

        return new PolyResponse(txHash, receipt);
    },
    async estimateGasAsync(
    {{> typed_params inputs=inputs}}
        factor?: number,
        txData: Partial<TxData> = {},
    ): Promise<number> {
        const self = this as any as {{contractName}}Contract;
        const inputAbi = self._lookupAbi('{{this.functionSignature}}').inputs;
        [{{> params inputs=inputs}}] = BaseContract._formatABIDataItemList(inputAbi, [{{> params inputs=inputs}}], BaseContract._bigNumberToString);
        const encodedData = self._lookupEthersInterface('{{this.functionSignature}}').functions.{{this.name}}.encode([{{> params inputs=inputs}}]);
        const defaultFromAddress = (await self._web3Wrapper.getAvailableAddressesAsync())[0];
        const contractDefaults = _.defaults(
                self._web3Wrapper.getContractDefaults(),
                {
                    from: defaultFromAddress 
                }
            );
        const txDataWithDefaults = await BaseContract._applyDefaultsToTxDataAsync(
            {
                to: self.address,
                ...txData,
                data: encodedData,
            },
            contractDefaults
        );
        const gas = await self._web3Wrapper.estimateGasAsync(txDataWithDefaults);
        const networkGasLimit = (await self._web3Wrapper.getBlockWithTransactionDataAsync('latest')).gasLimit;
        const _factor = _.isUndefined(factor) ? self._defaultEstimateGasFactor : factor;
        const _safetyGasEstimation = Math.round(_factor * gas);
        return (_safetyGasEstimation > networkGasLimit) ? networkGasLimit : _safetyGasEstimation;
    },
    getABIEncodedTransactionData(
    {{> typed_params inputs=inputs}}
    ): string {
        const self = this as any as {{contractName}}Contract;
        const inputAbi = self._lookupAbi('{{this.functionSignature}}').inputs;
        [{{> params inputs=inputs}}] = BaseContract._formatABIDataItemList(inputAbi, [{{> params inputs=inputs}}], BaseContract._bigNumberToString);
        const abiEncodedTransactionData = self._lookupEthersInterface('{{this.functionSignature}}').functions.{{this.name}}.encode([{{> params inputs=inputs}}]);
        return abiEncodedTransactionData;
    },
    {{> callAsync}}
};
